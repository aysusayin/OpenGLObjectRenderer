// OpenGLProject.cpp : Defines the entry point for the console application.
//
#include "glad/glad.h"
#include <GLFW/glfw3.h>
#include "Shader.h"
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtc/type_ptr.hpp>
#include "Object3D.h"
#include <vector>
#include <GL/gl.h>

GLFWwindow *window;
glm::vec3 cameraPos = glm::vec3(-3.0f, -10.0, 8.0f);
glm::vec3 cameraTarget = glm::vec3(-3.0f, 0.0f, 0.0f);
glm::vec3 cameraUp = glm::vec3(0.0f, 1.0f, 0.0f);

void key_callback(GLFWwindow *window, int key, int scancode, int action, int mode) {
    if (key == GLFW_KEY_ESCAPE && action == GLFW_PRESS)
        glfwSetWindowShouldClose(window, GL_TRUE);
}

void GLClear() {
    // Clear the colorbuffer
    glClearColor(0.2f, 0.3f, 0.3f, 1.0f);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
}

void GLInit(const int width, const int height) {
    // Init GLFW
    glfwInit();
    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
    glfwWindowHint(GLFW_RESIZABLE, GL_FALSE);
    glfwWindowHint(GLFW_SAMPLES, 4);

    window = glfwCreateWindow(width, height, "DANCING TEAPOTS: Bezier Surfaces", nullptr, nullptr);
    glfwMakeContextCurrent(window);
    glfwSetKeyCallback(window, key_callback);
    glfwSwapInterval(2);

    // glad: load all OpenGL function pointers
    if (!gladLoadGLLoader((GLADloadproc) glfwGetProcAddress)) {
        std::cout << "Failed to initialize GLAD" << std::endl;
        return;
    }

    // Define the viewport dimensions
    glViewport(0, 0, width, height);

    // Enable depth test
    glEnable(GL_BLEND);
    glEnable(GL_DEPTH_TEST);
    //glDepthFunc(GL_LESS);
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
}

// The view matrix is generated by glm::lookAt call. It constructs an affine transformation matrix from the camera position,
// camera look target position and camera up vector.
glm::mat4 calculateViewTransform() {
    auto view = glm::lookAt(cameraPos, cameraTarget, cameraUp);
    return view;
}

glm::mat4 calculateProjectionTransform(const int width, const int height) {
    return glm::perspective<float>(glm::radians(45.0f), (float) width / (float) height, 0.1f, 100.0f);
}

glm::mat4 calculateAnimationTransform() {
    // This part is for animation
    float coeff = std::sin((float)glfwGetTime());
    //vp = glm::scale(vp, coeff * glm::vec3(1, 1, 1));
    glm:: mat4 vp = glm::mat4(1);
    vp = glm::rotate(vp, (float)glfwGetTime(), glm::vec3(0.0f, 0.0f, 1.0f));
    vp = glm::translate(vp, coeff * glm::vec3(0.0f, 5.0f, 0.0f));
    return vp;
}

int main() {
    int screenWidth = 800, screenHeight = 600;
    GLInit(screenWidth, screenHeight);
    std::vector<Object3D *> listOfObjects;

    Object3D *utahTeapot = new Object3D();
    listOfObjects.push_back(utahTeapot);
    Object3D *utahTeapot2 = new Object3D();
    listOfObjects.push_back(utahTeapot2);

    Shader shader("res/Basic.shader");

    while (!glfwWindowShouldClose(window)) {
        glfwPollEvents();
        GLClear();

        shader.Use(); // Use shader

        glm::mat4 view = calculateViewTransform();  // Create camera transformation
        glm::mat4 projection = calculateProjectionTransform(screenWidth, screenHeight); // Create projection transformation
        glm:: mat4 animation = calculateAnimationTransform();
        glm::mat4 vp =  projection * view * animation;

        for (int i = 0; i < listOfObjects.size(); i++) {
            if(i==1){
                vp = glm::translate(vp, glm::vec3(0.0f, -5.0f, 0.0f));
            }
            listOfObjects[i]->DrawObject(&shader, &vp);
        }
        glfwSwapBuffers(window);
    }
    // Clean up
    for (auto pObj : listOfObjects) {
        delete pObj;
    }
    shader.Delete();
    glfwTerminate();
    return 0;
}
